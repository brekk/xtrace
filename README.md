![xtrace](https://cdn.rawgit.com/brekk/xtrace/554215b/logo.svg)

> a tool for adding clarity to your compositional-pipelines or just invoking side-effects in a clean way

Originally inspired by [this book](https://drboolean.gitbooks.io/mostly-adequate-guide/content/ch5.html#debugging), this is a more fully-fledged solution for adding simple side-effects to a given operation.

```js
import R from 'ramda'

const multiply = R.curry((a, b) => a * b)

const iterateOverEveryElementAndMultiplyBy5 = R.map(multiply(5))
console.log(iterateOverEveryElementAndMultiplyBy5([1,2,3,4,5])) // 5, 10, 15, 20, 25
```

What can we do if we wanna make this function easy to inspect as it iterates over these values?

```js
import {trace} from 'xtrace'

const iterateOverEveryElementAndMultiplyBy5WithLogging = R.pipe(
  trace(`input!`),
  R.map(
    R.pipe(
      trace(`5 *`),
      multiply(5)
    )
  ),
  trace(`output!`)
)
```

What about conditional logging? Here's an example using `debug`

```js
import Debug from 'debug'
import {xtrace} from 'xtrace'
const debug = Debug(`my-debug-logger`)
const dtrace = xtrace(debug)

const verboseConditionalLoggerWhenMultiplyingBy5 = R.pipe(
  dtrace(`input!`),
  R.map(
    R.pipe(
      dtrace(`5 *`),
      multiply(5)
    )
  ),
  dtrace(`output!`)
)
```

Or, for convenience, just use the exported `debug` object (added `0.0.9`):

```js
import {debug} from 'xtrace'
const {generate} = debug
const [trace, extra, wordVomit] = generate([`log:critical`, `log:info`,`log:verbose`], false)

const reallyCerboseConditionalLoggerWhenMultiplyingBy5 = R.pipe(
  extra(`input!`),
  R.map(
    R.pipe(
      wordVomit(`5 *`),
      multiply(5)
    )
  ),
  extra(`output!`)
)
```

If you want to be able to inspect the values as they pass through, pass `true` as the second parameter to `generate`:

```js
const {generate} = debug
const [extraInspect, wordVomitInspect] = generate([`log:info`,`log:verbose`], true)

const reallyCerboseConditionalLoggerWhenMultiplyingBy5 = R.pipe(
  extra(`type of input?`, (x) => typeof x), // add type inspection
  R.map(
    R.pipe(
      wordVomit(`5 *`, (x) => x.toString()), // convert to string, for fun
      multiply(5)
    )
  ),
  extra(`output!`, someGlobalLogger) // ostensibly a more specific logger
)
```

_NB: All of the stuff in the `debug` object can be derived from judicious application of `xtrace.debug.custom.generate`, please see the tests for more._

#### API

<!-- Generated by documentation.js. Update this documentation by updating the source code. -->

##### xtrace.debug.custom

**Parameters**

-   `fn` **[function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)** a function to set as the side-effect
-   `a` **any** first param to log (or whatever is being passed in as the side-effect)
-   `inspect` **[function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)** a function to inspect the second parameter
-   `b` **any** second param to log (or whatever)

Returns **any** b - whatever b parameter was

##### xtrace.debug.custom

**Parameters**

-   `fn` **[function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)** a function to act as a debug ((a) => (b) => a + b)
-   `interactive` **[boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)** make an inspector (true) or a logger (false)
-   `namespaces` **[Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)&lt;strings>** a list of namespaces to pass to the debug function

Returns **[function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)** an inspector or a logger, or something else, if you passed in something
weird as `fn`

##### xtrace.debug.custom

**Parameters**

-   `fn` **[function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)** a function to set as the side-effect
-   `a` **any** first param to log (or whatever is being passed in as the side-effect)
-   `b` **any** second param to log (or whatever)

Returns **any** b - whatever b parameter was

##### xtrace.debug.custom

Likely this function shouldn't be invoked directly unless you are behaving with intention,
but see the tests for more.

**Parameters**

-   `bug` **[function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)** a function which is closured like the `debug` function
-   `fn` **[function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)** function to invoke after the debug function

Returns **[function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)** a HOF which can map over a functor

##### sideEffect

The high-level abstraction for identity-closure side-effects

**Parameters**

-   `effect` **[function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)** function which does something independent of the returned value
-   `tag` **any** first value to pass to the side effect
-   `inspect` **[function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)** function which wraps the second value to pass to the side effect
-   `input` **any** the return value, and the value passed to the inspect function

**Examples**

```javascript
import {sideEffect, $, I} from 'xtrace'
import _debug from 'debug'
const debug = _debug(`my:custom:debugger`)
const trace = sideEffect(debug, $, I, $)
// [...]
trace(`input`, 5) // only logs if DEBUG env var (e.g. DEBUG=my:custom:debugger node this-file.js)
```

Returns **any** whatever input is

##### xtrace

xtrace is the same as sideEffect, only we dropped the inspect parameter by passing identity

**Parameters**

-   `effect` **[function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)** function which does something independent of the returned value
-   `tag` **any** first value to pass to the side effect
-   `input` **any** the return value, and the value passed to the side effect

**Examples**

```javascript
import {xtrace} from 'xtrace'
import _debug from 'debug'
const debug = _debug(`my:custom:debugger`)
const trace = xtrace(debug)
// [...]
trace(`input`, 5) // only logs if DEBUG env var (e.g. DEBUG=my:custom:debugger node this-file.js)
```

Returns **any** whatever input is

##### trace

trace is the same as xtrace, only we applied the first parameter as console.log, for convenience

**Parameters**

-   `tag` **any** first value to pass to the console.log
-   `input` **any** the return value, and the value passed to the console.log

**Examples**

```javascript
import {trace} from 'xtrace'
trace(`whatever`, 5) // logs 'whatever', 5
```

Returns **any** whatever input is

#### Similar efforts:

-   `composition-trace` - <https://github.com/stevemao/composition-trace>
